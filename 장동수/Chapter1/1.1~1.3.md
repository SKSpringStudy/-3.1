
## 1.2 DAO의 분리
### 1.2.1 관심사의 분리

미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. 만약 어떠한 기술을 다른 것으로 바꿨다고 비즈니스 로직이 담긴 코드의 구조를 모두 변경해야 한다면 많은 시간이 걸릴 것이다.
우리가 준비해야 할 일은 한가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.
관심사의 분리를 통해 변화가 필요할 때 해당 관심사에 대한 것만 수정하여 효과적으로 집중할 수 있게 만들어주는 것이다.

### 1.2.2 커넥션 만들기의 추출
#### UserDao의 관심사항
* DB 커넥션
* Statement 생성,실행
* Statement, Connection 닫기

중복코드를 단일 class 안에서 하나의 메소드로 추출한다.

### 1.2.3 DB 커넥션 만들기의 독립
여러 방법이 존재한다.

#### 상속을 통한 확장
* 'DB 커넥션 연결 관심'을 분리 >> 상속을 이용하여 서브클래스에 관심사를 둔다.
```java
public abstract class UserDAO {
    public abstract Connection getConnection() throws ClassNotFountException, SQLException;
}
```
* 관심사가 두가지로 나뉜다.
    * UserDao - SQL 작성, 피라미터 바인딩, 쿼리 실행, 검색정보 전달
    * NUserDao/DUserDao - DB 연결 방법

#### 디자인 패턴
* 템플릿 메소드 패턴 Template Method Pattern
> 특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴
* 팩토리 메소드 패턴 Factory Method Pattern
> 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴 즉, 인스턴스 생성을 서브 클래스에게 위임한다.

#### 상속을 통한 확장의 단점
* 만약 UserDao가 다른 목적을 위해 상속을 사용하고 있다면? 자바 클래스의 다중상속을 허용하지 않는다.
* 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다.
* 만약 UserDao 외의 DAO 클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복되어서 나타나는 문제 발생한다.

## 1.3 DAO의 확장
### 1.3.1 클래스의 분리

서로 독립적인 class로 존재하게 한다.
```java
public class SimpleConnectionMaker {
    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost/toby", "spring", "book");
    }
}
```
#### 문제점
SimpleConnectionMaker 의 makeNewConnection() 이름 변경만 있어도 UserDao가 변경이 일어난다.
다른종류의 SimpleConnectionMaker 를 사용하려면 UserDao의 변경이 일어난다.
```java
public UserDao() {
    this.simpleConnectionMaker = new SimpleConnectionMaker();
}
```
### 1.3.2 인터페이스의 도입
UserDao가 인터페이스를 사용하게 한다면 인터페이스의 메소드를 





```java
@Tag(name = "Users Controller", description = "유저 관련 컨트롤러")
    @PostMapping("/infoDetail")
    @Operation(summary = "유저 세부 정보 생성", description = "User 세부 정보를 생성합니다.")
    public SingleResult<UserInfoDetailResponse> createInfoDetail(
            @Parameter(name = "X-AUTH-TOKEN", description = "로그인 성공 후 AccessToken", in = ParameterIn.HEADER) String token,
            @RequestBody UserInfoDetailRequest userInfoDetailRequest
    ) {
        return responseService.getSingleResult(usersService.createInfoDetail(userInfoDetailRequest));
    }
```
