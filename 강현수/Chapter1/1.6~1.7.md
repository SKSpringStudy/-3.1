# 1.6 싱글톤 레지스트리와 오브젝트 스코프
`DaoFactory`를 직접 사용하는 것과 `@Configuration`을 추가하여 애플리케이션 컨텍스트로 사용하는 것이 어떤 차이가 있는지 알아보자. <br/>

```java
public class UserDaoTest {

    public static void main(String[] args) {
        DaoFactory factory = new DaoFactory();
        UserDao dao1 = factory.userDao();
        UserDao dao2 = factory.userDao();
        System.out.println(dao1);
        System.out.println(dao2);

        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao3 = context.getBean("userDao", UserDao.class);
        UserDao dao4 = context.getBean("userDao", UserDao.class);
        System.out.println("dao3 = " + dao3);
        System.out.println("dao4 = " + dao4);
    }

}
```

실행결과를 살펴보면 다음과 같다.
```java
//DaoFactory를 사용한 결과
user.dao.UserDao@62043840
user.dao.UserDao@5315b42e

//ApplicationContext를 사용한 결과
dao3 = user.dao.UserDao@6e2829c7
dao4 = user.dao.UserDao@6e2829c7
```

`DaoFactory`를 사용한 결과는 어찌보면 당연한 결과라고 생각할 수 있다. `userDao()`를 호출할 때마다 new 연산자에 의해 새로운 오브젝트가 생성되니 말이다. <br/>
여기서 궁금한 점은 `ApplicationContext`를 사용했을 때 **어떻게 동일한 오브젝트를 가져올 수 있었는가?** 이다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 IoC 컨테이너이면서 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리**이다. <br/>
스프링은 별다른 설정을 하지 않으면 기본적으로 내부에서 생성하는 빈 오브젝트들을 싱글톤으로 만든다. <br/>

#### **서버 애플리케이션과 싱글톤**
스프링이 빈을 싱글톤으로 만드는 이유는 바로 주로 스프링이 적용되는 대상이 서버환경이기 때문이다. <br/>
대규모의 엔터프라이즈 서버환경은 클라이언트로부터 수많은 요청이 들어온다. 이때 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 생성해서 사용한다고 하면 서버에 큰 부하가 올 것이다. <br/>
그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 도입하여 서블릿 클래스 당 하나의 오브젝트만 만들어두고, 멀티스레드 환경에서 오브젝트가 싱글톤으로 동작하게 하였다. 따라서 서버환경에서는 서비스 싱글톤의 사용이 권장되는데, 디자인 패턴에서의 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다.

#### **싱글톤 패턴의 한계**
일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.
1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤 패턴은 자신만이 자기 오브젝트를 만들 수 있기 때문에 생성자를 private으로 제한한다.
- 문제는 생성자가 private이면 상속이 불가능하다는 것이다. 이는 객체지향적인 설계의 장점을 적용하기 어려운 문제가 생긴다.
2. 싱글톤은 테스트하기 힘들다.
- 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 mock오브젝트 등으로 대체하기가 힘들다.
- 초기화 과정에서 생성자 등을 통해 오브젝트를 동적으로 주입하기도 힘들기 때문에 테스트를 하기 힘들다. 엔터프라이즈 개발의 핵심인 테스트를 하기 힘들다는 것은 큰 단점이다.
3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장할 수 없다.
- 서버에서 클래스 로더를 어떻게 구성하고 있냐에 따라 싱글톤임에도 하나 이상의 오브젝트가 만들어질 수 있다.
- 여러 개의 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.
4. 싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.
- 싱글톤을 사용하는 클라이언트가 정해져있지 않기 때문에 싱글톤의 스태틱 메서드로 싱글톤에 누구든지 쉽게 접근할 수 있어 전역 상태로 사용되기 쉽다.

#### **싱글톤 레지스트리**
자바의 싱글톤 패턴 구현 방식의 단점을 보완하고자 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 이것을 `싱글톤 레지스트리`라고 한다. <br/>
싱글톤 레지스트리의 장점은 스태틱 메서드와 private 연산자를 사용하지 않은 평범한 자바 클래스도 싱글톤으로 활용하게 해준다는 점이다. <br/>
**스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신하여 싱글톤을 만들고 관리해주는 싱글톤 레지스트리이다.**

### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근할 수 있기 때문에 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 가지고 있지 않은 **무상태 방식**으로 만들어져야 한다. <br/>
상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나 DB나 서버의 리소스로부터 생성한 정보는 파라미터와 로컬 변수, 리턴 값 등을 이용하여 처리한다. <br/>
때문에 매번 새로운 값으로 바뀔 수 있는 인스턴스 변수는 사용에 주의해야 하는데, 만약 읽기 전용으로 쓸 변수라면 인스턴스 변수로 사용해도 괜찮다. <br/>

### 1.6.3 스프링 빈의 스코프
스프링이 관리하는 빈이 생성되고, 존재하고, 적용되는 범위를 `빈의 스코프`라고 한다. <br/>
스프링에서 만들어지는 대부분의 빈은 스프링 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너와 라이프 사이클을 함께하는 싱글톤 스코프를 갖는다. <br/>
다만 경우에 따라서 싱글톤 스코프외의 스코프를 가질 수 있다. 대표적으로 `프로토타입 스코프`가 있는데, 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 새롭게 오브젝트를 생성한다. <br/>
(그 외의 다양한 스코프에 대해서는 10장에서..)

# 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전(IoC)와 의존관계 주입
스프링 IoC의 동작원리는 **의존관계 주입(Dependency Injection)** 이다. <br/>

### 1.7.2 런타임 의존관계 설정
#### **의존관계**
"A가 B에게 의존한다" 라는 것은 B가 변하면 A에게도 영향을 미친다는 것이다. (A -> B) <br/>
그렇기에 구체적인 클래스끼리 의존관계를 맺는 것보다, 인터페이스에 대해서만 의존관계를 맺게 하면 **클래스간의 관계는 느슨한 관계를 맺을 수 있다.**
<br/>

우리가 작성했던 `UserDao`의 의존관계에 대해 살펴보자.
`UserDao`를 보면 `ConnectionMaker`인터페이스를 의존하고 있는 것을 볼 수 있다. 그렇기에 `ConnectionMaker`를 구현한 `DConnectionMaker` 등이 바뀌거나 변화가 생겨도 `UserDao`에 영향을 주지 않는다. <br/>
즉 `UserDao`는  `DConnectionMaker`클래스의 존재도 모르고 있다. <br/>

#### **런타임 의존관계와 모델링 시점의 의존관계**
UML에서 말하는 모델이나 코드에서 드러나는 의존관계 말고, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. <br/>
런타임 의존관계 또는 오브젝트 의존관계인테, 이는 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. <br/>

인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 `UserDao`의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수가 없다. 이를 **의존 오브젝트**라고 한다. <br/>

#### **의존관계 주입**
의존관계 주입은 구체적인 의존 오브젝트와 클라이언트를 런타임 시에 연결해주는 작업을 말하는데, 세 가지 조건을 충족하는 작업을 말한다.

1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. (인터페이스에만 의존하고 있어야 함)
2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제3의 존재가 결정한다.
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다.

DI의 핵심은 설계 시점에서는 몰랐던 두 오브젝트의 관계를 맺어주는 제3의 존재가 있다는 것이다. 앞에서 작성했던 `DaoFactory`, 이를 일반화했던 `ApplicationContext` 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 제3의 존재라고 볼 수 있다.

### 1.7.3 의존관계 검색과 주입
스프링이 제공하는 IoC 방법에는 의존관계를 맺는 방법이 외부로부터의 주입이 아닌 스스로 검색을 하는 **의존관계 검색**이라고 불리는 것도 있다. <br/>
의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다(런타임시에). 
물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하는 것은 아니다. <br/>
오브젝트를 결정하는 것과 생성작업은 IoC로 맡기지만, 이를 가져올 때는 메서드나 생성자를 통한 주입이 아닌 스스로 컨테이너에게 요청한다. <br/>

`UserDao`의 생성자를 변경해보자. <br/>
```java
public UserDao() {
    DaoFactory daoFactory = new DaoFactory();
    this.connectionMaker = daoFactory.connectionMaker();
}
```

의존관계를 외부로부터 주입을 받는 것이 아닌 스스로 IoC컨테이너인 `DaoFactory`에게 요청하는 것이다. <br/>
이를 일반화한다면 `ApplicationContext`등을 직접 불러와 검색을 요청하는 것이라고 볼 수 있다. (ApplicationContext의 `getBean()` 메서드가 이를 지원한다.)<br/>

의존관계 주입과 의존관계 검색의 가장 큰 차이점은 바로 <br/>
의존관계 검색에서는 검색하는 오브젝트는 **자신이 빈 오브젝트일 필요가 없다는 것**이다. `UserDao`에서 `getBean()`을 이용하여 검색을 적용했을 때, `UserDao`는 굳이 빈 오브젝트일 필요가 없다.<br/>
반면에 의존관계 주입에서는 `UserDao`와 `ConnectionMaker` 사이에 DI가 적용되려면 둘 다 빈 오브젝트여야 한다. <br/>

### 1.7.5 메서드를 이용한 의존관계 주입
#### **1. 수정자 메서드를 이용한 주입**
setter 메서드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용된다. (메서드의 이름은 항상 set으로 시작한다.) <br/>
수정자라고도 불리는데, 수정자 메서드의 핵심은 전달된 값을 보통 내부 인스턴스 변수에 저장하는 것이다. <br/>
외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가, 내부 메서드에서 사용하게 하는 DI 방식에 활용하기 적당하다. <br/>

#### **2. 일반 메서드를 이용한 주입**
여러 개의 파라미터를 받는 일반 메서드를 DI용으로 사용하는 방식이다. <br/>

수정자 메서드 방식의 DI를 `UserDao`에 적용해보자. 생성자를 지우고 메서드를 추가한다.
```java
public class UserDao {
    private ConnectionMaker connectionMaker;

    public void setConnectionMaker(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```
`DaoFactory`도 변경해야 한다.
```java
@Bean
public UserDao userDao() {
    UserDao userDao = new UserDao();
    userDao.setConnectionMaker(connectionMaker());
    return userDao;
}
```

