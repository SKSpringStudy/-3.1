# 1.6 싱글톤 레지스트리와 오브젝트 스코프
`DaoFactory`를 직접 사용하는 것과 `@Configuration`을 추가하여 애플리케이션 컨텍스트로 사용하는 것이 어떤 차이가 있는지 알아보자. <br/>

```java
public class UserDaoTest {

    public static void main(String[] args) {
        DaoFactory factory = new DaoFactory();
        UserDao dao1 = factory.userDao();
        UserDao dao2 = factory.userDao();
        System.out.println(dao1);
        System.out.println(dao2);

        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao3 = context.getBean("userDao", UserDao.class);
        UserDao dao4 = context.getBean("userDao", UserDao.class);
        System.out.println("dao3 = " + dao3);
        System.out.println("dao4 = " + dao4);
    }

}
```

실행결과를 살펴보면 다음과 같다.
```java
//DaoFactory를 사용한 결과
user.dao.UserDao@62043840
user.dao.UserDao@5315b42e

//ApplicationContext를 사용한 결과
dao3 = user.dao.UserDao@6e2829c7
dao4 = user.dao.UserDao@6e2829c7
```

`DaoFactory`를 사용한 결과는 어찌보면 당연한 결과라고 생각할 수 있다. `userDao()`를 호출할 때마다 new 연산자에 의해 새로운 오브젝트가 생성되니 말이다. <br/>
여기서 궁금한 점은 `ApplicationContext`를 사용했을 때 **어떻게 동일한 오브젝트를 가져올 수 있었는가?** 이다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 IoC 컨테이너이면서 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리**이다. <br/>
스프링은 별다른 설정을 하지 않으면 기본적으로 내부에서 생성하는 빈 오브젝트들을 싱글톤으로 만든다. <br/>

#### **서버 애플리케이션과 싱글톤**
스프링이 빈을 싱글톤으로 만드는 이유는 바로 주로 스프링이 적용되는 대상이 서버환경이기 때문이다. <br/>
대규모의 엔터프라이즈 서버환경은 클라이언트로부터 수많은 요청이 들어온다. 이때 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 생성해서 사용한다고 하면 서버에 큰 부하가 올 것이다. <br/>
그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 도입하여 서블릿 클래스 당 하나의 오브젝트만 만들어두고, 멀티스레드 환경에서 오브젝트가 싱글톤으로 동작하게 하였다. 따라서 서버환경에서는 서비스 싱글톤의 사용이 권장되는데, 디자인 패턴에서의 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다.

#### **싱글톤 패턴의 한계**
일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.
1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤 패턴은 자신만이 자기 오브젝트를 만들 수 있기 때문에 생성자를 private으로 제한한다.
- 문제는 생성자가 private이면 상속이 불가능하다는 것이다. 이는 객체지향적인 설계의 장점을 적용하기 어려운 문제가 생긴다.
2. 싱글톤은 테스트하기 힘들다.
- 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 mock오브젝트 등으로 대체하기가 힘들다.
- 초기화 과정에서 생성자 등을 통해 오브젝트를 동적으로 주입하기도 힘들기 때문에 테스트를 하기 힘들다. 엔터프라이즈 개발의 핵심인 테스트를 하기 힘들다는 것은 큰 단점이다.
3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장할 수 없다.
- 서버에서 클래스 로더를 어떻게 구성하고 있냐에 따라 싱글톤임에도 하나 이상의 오브젝트가 만들어질 수 있다.
- 여러 개의 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.
4. 싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.
- 싱글톤을 사용하는 클라이언트가 정해져있지 않기 때문에 싱글톤의 스태틱 메서드로 싱글톤에 누구든지 쉽게 접근할 수 있어 전역 상태로 사용되기 쉽다.

#### **싱글톤 레지스트리**
자바의 싱글톤 패턴 구현 방식의 단점을 보완하고자 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 이것을 `싱글톤 레지스트리`라고 한다. <br/>
싱글톤 레지스트리의 장점은 스태틱 메서드와 private 연산자를 사용하지 않은 평범한 자바 클래스도 싱글톤으로 활용하게 해준다는 점이다. <br/>
**스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신하여 싱글톤을 만들고 관리해주는 싱글톤 레지스트리이다.**

### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근할 수 있기 때문에 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 가지고 있지 않은 **무상태 방식**으로 만들어져야 한다. <br/>
상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나 DB나 서버의 리소스로부터 생성한 정보는 파라미터와 로컬 변수, 리턴 값 등을 이용하여 처리한다. <br/>
때문에 매번 새로운 값으로 바뀔 수 있는 인스턴스 변수는 사용에 주의해야 하는데, 만약 읽기 전용으로 쓸 변수라면 인스턴스 변수로 사용해도 괜찮다. <br/>

### 1.6.3 스프링 빈의 스코프
스프링이 관리하는 빈이 생성되고, 존재하고, 적용되는 범위를 `빈의 스코프`라고 한다. <br/>
스프링에서 만들어지는 대부분의 빈은 스프링 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너와 라이프 사이클을 함께하는 싱글톤 스코프를 갖는다. <br/>
다만 경우에 따라서 싱글톤 스코프외의 스코프를 가질 수 있다. 대표적으로 `프로토타입 스코프`가 있는데, 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 새롭게 오브젝트를 생성한다. <br/>
(그 외의 다양한 스코프에 대해서는 10장에서..)

# 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전(IoC)와 의존관계 주입


