# 1.4 제어의 역전
### 1.4.1 오브젝트 팩토리
지금까지 `UserDao`를 깔끔하게 리팩토링하는 작업을 수행했는데, 이 과정에서 `Main`이 `ConnectionMaker`의 구현클래스를 결정하는 일을 떠맡아버렸다. <br/>
하지만 `Main`은 `UserDao`가 잘 동작하는지 테스트하기 위한 용도이지 구현클래스를 정하는 또 다른 책임을 져서는 안된다. <br/>

**팩토리**
<br/>

`UserDao`와 `ConnectionMaker`구현클래스를 분리시킬 기능을 담당할 클래스를 만들어보자.
```java
package ch1.user.dao;

public class DaoFactory {

    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }

}
```
```java
public class Main {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new DaoFactory().userDao();
        ...
    }
}
```
이제 `Main`에서 `ConnectionMaker`구현클래스를 결정하지 않아도 되게 되었다.

### 1.4.2 오브젝트 팩토리의 활용
만약 `UserDao`가 아닌 다른 DAO의 생성 기능이 필요하다면 어떻게 될까? -> `ConnectionMaker`구현클래스의 오브젝트가 중복되어 생성될 것이다.
따라서 `ConnecionMaker`구현클래스의 오브젝트를 생성하는 부분을 따로 분리해줘야 한다.
```java
public class DaoFactory {

    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }
    
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }

}
```

### 1.4.3 제어권의 이전을 통한 제어관계 역전
**제어의 역전(Inverse of Control)이란?**
일반적으로 
