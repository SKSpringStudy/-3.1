## DAO의 분리
현재까지의 우리의 DAO는 하나의 메소드안에 여러 책임과 중복된 코드들이 존재한다.

초반에 코드를 짤 때는 코드가 몇 줄 안되기 때문에 변경이 일어나도 바꾸는것이 어렵지 않다.
하지만 코드가 길어지고 프로젝트의 규모가 커지다보면 한가지의 변경 사항때문에 몇 백줄을 바꾸는 일도 일어날 수 있다.

이런일이 발생하지 않기 위해서 우리는 ***분리와 확장***을 고려한 설계를 해아한다.

### 분리란?
우리가 단순하게 DB 접속용 암호를 바꾸기 위해 DAO 클래스를 수백개를 바꾼다면 굉장히 비효율적이 아닐 수 없다.
다른 개발자가 바꾼 코드때문에 내가 만든 코드도 바꿔야한다면 더 최악이다.

우리는 이런 불상사를 막기 위해 관심이 같은 것끼리는 모으고 관심이 다른 것은 따로 떨어트려나야 한다.
그럼 관심이란 것은 무엇일까?

### 관심
UserDAO를 보면 
1. DB 커넥션을 어떻게 가져올까

2. DB에 보낼 SQL문장을 담을 statement를 만들고 실행하기

3. 작업이 끝난후 Statement와 Connection 오브젝트를 닫고 공유 리소스 시스템에 반환하기

이렇게 3가지의 관심사가 하나의 메소드에서 실행중이다.

### 분리의 시작 중복 코드 추출
이제 부터 이것을 분리해보도록하자.
먼저 여러 메소드에서 add()와 get() 메소드 모두에서 중복되는 1. DB 커넥션을 어떻게 가져올까 부분을 메소드로 추출하자
이 코드가 100번 반복되는 프로젝트에서 DB가 MySQL이 아닌 MongoDB로 바뀌었다고 생각해보자 Driver부터 URL까지 100번 바꿀 생각을 하니 끔찍하다.
```java
private static Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName ("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/tobbyspring", "root","compact20");
        return c;
}
```
위와 같이 커넥션 부분을 처리하는 코드만 getConnection()메소드로 추출해주었다.
만약 DB커넥션에 관한 변경이 이뤄진다면 이부분의 코드만 바꾸면 될 것이다.
우리는 이와같은 작업을 ***리팩토링***이라고 한다.

### 상속을 통한 확장 + 관심사의 분리 
우리가 리팩토링한 getConnection()이라는 메소드를 개발자 취향에 따라서 다른 DB를 쓰던지 상관 안쓰고 싶다고 해보자.
UserDao의 getConnection()을 추상메소드로 다음과 같이 만드는 것이다.
```java
public abstract Connection getConnection() throws ClassNotFoundException,SQLException;
```
추상메소드는 코드는 없지만 메소드 자체는 존재하기 때문에 add()나 get()에서 코드 흐름은 유지 시킬 수 있다.

이러한 디자인 패턴을 ***템플릿 메소드 패턴***이라고 한다.

우리는 상속을 통해서 손쉽게 확장되는 코드를 만들었다.
add() 코드를 보자
```java
public void add(User user) throws ClassNotFoundException, SQLException {

        Connection c = getConnection();
        PreparedStatement ps = c.prepareStatement ("insert into users(id, name, password) values(?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user .getName ());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close(); c.close();
    }
```
add()는 getConnection()이 어떤 내부 동작으로 Connection 오브젝트를 가져오든 상관없이 
현재 Connection 인터페이스의 메소드를 사용하여 2번 3번 로직만 처리 하면 된다.

![image](https://user-images.githubusercontent.com/74056843/212358450-6e76ad5c-61ae-42d3-b60c-692391f63c7b.png)

DB Connection을 가져오는 관심사를 분리해두었기 때문에 add()는 2번 3번 기능에만 책임과 관심을 가지면 되는 상태가 되었다.

이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하는 방법을 ***팩토리 메소드 패턴***이라고 한다.

### 템플릿 메소드 패턴 vs 팩토리 메소드 패턴
템플릿 메소드 패턴은 메소드를 추상메소드로 만들어 수퍼클래스의 기능을 확장할 때 사용한다. 
변하지 않는 기능은 슈퍼클래스에 놔두고 자주 변경되고 확장할 기능은 서브클래스에서 만들 때 많이 사용된다.

팩토리 메소드 패턴은 똑같이 상속을 통해 기능을 
ㅎㅗ




